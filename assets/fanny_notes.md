PART 3

# üíª **FD**: 

## üõë Pour fermer proprement des ports : 
- Close de **1 √† 1024** car cest le nombre de fd dun systeme de base linux. command limit pour trouver si besoin

---

# se connecter a inspIRCd et hexchat
```bash

‚ûú  inspircd-3.14.0 ./bin/inspircd  --config ./conf/examples/inspircd.conf.example --nofork
InspIRCd - Internet Relay Chat Daemon
See /INFO for contributors & authors

InspIRCd Process ID: 83146

Loading core modules ....................
InspIRCd is now running as 'penguin.omega.example.org'[422] with 1048576 max open sockets
```

ca va tourner sur local host et on pourra y acceder en desactivant le ssl
---


# **Plan**
Gestion des connexions et de l'authentification (Personne A)

Impl√©menter la gestion des connexions des clients (√©coute des connexions sur le port).
Authentifier les utilisateurs (nom d'utilisateur, mot de passe).
G√©rer la cr√©ation et la destruction des sockets pour chaque client.
Gestion des canaux et des utilisateurs (Personne B)

Impl√©menter la gestion des canaux (cr√©ation, suppression, rejoindre/quitter un canal).
G√©rer les utilisateurs dans chaque canal (ajouter/supprimer des utilisateurs).
Mettre en ≈ìuvre les r√¥les des utilisateurs (op√©rateurs vs utilisateurs r√©guliers).
Communication et gestion des messages (Personne C)

Impl√©menter l'envoi et la r√©ception des messages priv√©s entre utilisateurs.
G√©rer l'envoi et la r√©ception des messages de groupe dans les canaux.
Assurer la transmission des messages entre clients de mani√®re asynchrone.


# **General**

- IRC n'est pas limit√© √† une seule norme de codage comme ASCII ou UTF-8.
- certains octets ont des valeurs sp√©cifiques r√©serv√©es pour des codes de contr√¥le. Ces codes de contr√¥le sont utilis√©s pour d√©limiter les messages, c'est-√†-dire pour indiquer o√π commence et o√π se termine un message. Par exemple, des caract√®res comme newline (nouvelle ligne) peuvent √™tre utilis√©s pour marquer la fin d'un message.

## üîó **Server**:
- Les serveurs sont identifi√©s de mani√®re unique par leur nom, avec une longueur maximale de **63 caract√®res**.
- Chaque serveur a un identifiant unique √† l'√©chelle du r√©seau (dont le format d√©pend du type de client) et le serveur qui a introduit le client.

---

## üëÆ **Operators Client**:
### Pouvoirs sp√©ciaux :
- Les op√©rateurs peuvent effectuer des t√¢ches de r√©seau de base telles que d√©connecter et reconnecter des serveurs pour √©viter l'utilisation prolong√©e de mauvaises routes r√©seau.
- Un pouvoir plus controvers√© des op√©rateurs est la capacit√© de **forcer la d√©connexion** d'un utilisateur du r√©seau connect√© en fermant la connexion entre n'importe quel client et serveur.

---

## üõ†Ô∏è **Service Client**:
- Chaque client doit choisir un surnom unique, ou **"nick"**, d'une longueur maximale de **9 caract√®res**.
- Une fois connect√©, le client peut communiquer individuellement avec d'autres utilisateurs, ou ex√©cuter des commandes pour interroger l'√©tat du serveur (par exemple, obtenir une liste des utilisateurs connect√©s ou obtenir des d√©tails suppl√©mentaires sur un surnom sp√©cifique).
- Les **clients service** ont un acc√®s plus limit√© aux fonctions de discussion du protocole, mais peuvent avoir acc√®s √† des **donn√©es priv√©es des serveurs**.

---

## üì¢ **Channels**:
- Le canal est cr√©√© **implicitement** lorsque le premier client le rejoint, et il cesse d'exister lorsque le dernier client le quitte.
- Pendant que le canal existe, n'importe quel client peut se r√©f√©rer √† lui en utilisant son **nom**.
- Les noms de canaux sont des cha√Ænes commen√ßant par un **'&'** ou **'#'** et peuvent avoir une longueur allant jusqu'√† **200 caract√®res**.
- Restrictions de nom de canal : 
   - Le nom ne doit pas contenir d'espaces (`' '`), de contr√¥le G (`^G` ou ASCII 7), ou de virgule (`,`).
   
### üîí **Local Channel**:
- Ces canaux sont marqu√©s par le premier caract√®re √©tant un **'!'**, et seuls les clients du serveur o√π ils existent peuvent les rejoindre.

### **Actions**:
    JOIN
    -  If the channel doesn't exist prior
   to joining, the channel is created and the creating user becomes a
   channel operator. 
- if the channel is invite-only, (+i),
   then you may only join if invited
   -  a limit of ten (10)
   channels is recommended as being ample for both experienced and
   novice users.

### **Channel Operators**
  The channel operator (also referred to as a "chop" or "chanop") on a
   given channel is considered to 'own' that channel. 
   The commands which may only be used by channel operators are:

        KICK    - Eject a client from the channel
        MODE    - Change the channel's mode
        INVITE  - Invite a client to an invite-only channel (mode +i)
        TOPIC   - Change the channel topic in a mode +t channel

    -  A channel operator is identified by the '@' symbol next to their
   nickname whenever it is associated with a channel (ie replies to the
   NAMES, WHO and WHOIS commands).

---

## üë§ **User Client**:
### Utilise HexChat
- Les clients utilisateur sont g√©n√©ralement des programmes fournissant une interface **texte** pour communiquer via IRC. Ce type de client est souvent appel√© **"utilisateurs"**.

---

## üîç **Voc**:
- **Spanning Tree Protocol (STP)** : Un protocole de r√©seau utilis√© pour √©viter les boucles dans les r√©seaux locaux (LAN). Il cr√©e une **topologie arborescente** qui connecte tous les commutateurs tout en d√©sactivant les liens redondants.
- Un **tunnel** est un m√©canisme qui permet de transmettre des donn√©es d'un protocole √† un autre en encapsulant ces donn√©es.
 - **WebSocket** est un protocole de communication qui permet d'√©tablir une connexion bidirectionnelle persistante entre un client (comme un navigateur ou une application) et un serveur. Contrairement √† HTTP, o√π le client doit envoyer une requ√™te pour obtenir une r√©ponse du serveur, WebSocket permet au serveur d'envoyer des donn√©es au client √† tout moment, ce qui est id√©al pour des applications en temps r√©el.
 - **IP** = Internet protocol

 - **Sockets** : Un socket est un point de terminaison de communication bidirectionnelle entre deux programmes qui s'ex√©cutent sur un r√©seau. Il est utilis√© pour la communication entre les processus sur la m√™me machine ou sur diff√©rentes machines dans un r√©seau.

 - **Active socket** : Un socket actif est un socket qui est en cours d'utilisation pour la communication. Il est ouvert et pr√™t √† envoyer ou √† recevoir des donn√©es.

 - **Passive socket** : Un socket passif est un socket qui est en attente de demandes de connexion entrantes. Il est utilis√© pour √©couter les connexions entrantes et accepter les demandes de connexion.

 Active Socket (IRC Client):

**An active socket in IRC** represents the client-side connection to an IRC server. The IRC client initiates communication by connecting to the IRC server using a TCP/IP connection. Once connected, the client can send commands and messages to the server and receive responses. The IRC client socket handles user input, sends messages to the server, and processes server responses.
Passive Socket (IRC Server):

**A passive socket in IRC** represents the server-side listening socket that accepts incoming connections from IRC clients. The IRC server listens for incoming connections on a specific port, When a connection request is received from an IRC client, the server socket accepts the connection, creating a new socket for communication with that client. The IRC server socket manages multiple client connections simultaneously, handling commands and messages from each connected client and broadcasting messages to all clients as needed.


---

### üñ•Ô∏è R√©f√©rence :
- [RFC 2810](https://datatracker.ietf.org/doc/html/rfc2810)

---

## **Beej‚Äôs Guide to Network Programming !** üëã
2.1 Two Types of Internet Sockets
- ‚Äú**SOCK_STREAM** = two-way connected communication streams : envoie les packets dans l'ordre et sans perte
- **SOCK_DGRAM** = connectionless sockets‚Äù : envoie les packets sans garantie de r√©ception
- **Data Encapsulation** =  a packet is born, the packet is wrapped (‚Äúencapsulated‚Äù) in a header (and rarely a footer) by the first
protocol (say, the TFTP protocol), then the whole thing (TFTP header included) is encapsulated again by
the next protocol (say, UDP), then again by the next (IP), then again by the final protocol on the hardware
(physical) layer (say, Ethernet).

Layered Network Model
Application
‚Ä¢ Presentation
‚Ä¢ Session
‚Ä¢ Transport
‚Ä¢ Network
‚Ä¢ Data Link
‚Ä¢ Physical

Layered Network Model with unix : 
‚Ä¢ Application Layer (telnet, ftp, etc.)
‚Ä¢ Host-to-Host Transport Layer (TCP, UDP)
‚Ä¢ Internet Layer (IP and routing)
‚Ä¢ Network Access Layer (Ethernet, wi-fi, or whatever)

3.1 IP Addresses, versions 4 and 6

loopback address = ‚Äúthis machine I‚Äôm running on now‚Äù =  127.0.0.1 = localhost
Adresse IP priv√©e : Utilis√©e pour la communication sur un r√©seau local (local AreaNetwork).
Adresse IP publique : Utilis√©e pour la communication sur Internet.

Think of the IP address as the street address of a hotel, and the port number as the room number. 

3.4.1 Private (Or Disconnected) Networks

often times, the firewall translates ‚Äúinternal‚Äù IP addresses to ‚Äúexternal‚Äù (that everyone else in the
world knows) IP addresses using a process called Network Address Translation, or NAT

9.17 poll()
This function is very similar to select() in that they both watch sets of file descriptors for events, such
as incoming data ready to recv(), socket ready to send() data to, out-of-band data ready to recv(),
errors, etc.
The poll() function is used to monitor changes in the status of file descriptors. It blocks until an event occurs on one or more of the monitored file descriptors, or until the specified timeout expires.

raccourci cpplint : ctrl shift i

---

NExT PR 
**Summary:**
_**Implemented Features:**_


---
PR pour feature mode : 

**1 Cr√©ation des vecteurs modes et param√®tres** :
Les arguments sont s√©par√©s en deux parties : un vecteur modes pour les caract√®res de mode (+ ou - suivis de i, t, k, o, l) et un vecteur parameters pour leurs valeurs associ√©es. On utilise des boucles pour parcourir la cha√Æne de modes et associer chaque param√®tre √† son mode si n√©cessaire.

**2 V√©rification des cha√Ænes de modes :**
La fonction checkModeString valide la syntaxe des modes. Elle v√©rifie que chaque caract√®re correspond √† un mode autoris√© (i, t, k, o, l) et que les signes + ou - pr√©c√®dent les modes correctement. Si une erreur est d√©tect√©e (mode invalide ou mal form√©), une r√©ponse d‚Äôerreur est envoy√©e au client.

**3 Validation des arguments des modes :**
La fonction checkArguments s'assure que chaque mode n√©cessitant un argument (comme +k pour le mot de passe ou +l pour la limite d'utilisateurs) re√ßoit une valeur appropri√©e. Si un argument est absent ou invalide (par exemple, une valeur non num√©rique pour +l), une erreur ERR_NEEDMOREPARAMS ou un message explicite est renvoy√© au client.

**4 Application des modes :**
La fonction switchMode applique les changements de modes au canal en fonction des arguments valides. Les fonctions sp√©cifiques des objets Channel sont appel√©es pour activer/d√©sactiver les modes (activateInviteOnlyMode, updateKey, etc.). Les erreurs comme ERR_NOSUCHNICK (utilisateur inexistant pour +o) ou des indices invalides sont √©galement g√©r√©es ici.

**5 Retour d'√©tat et logs :**
Les modifications effectu√©es sont confirm√©es par des messages MODE envoy√©s aux clients. Les logs internes (activ√©s avec DEBUG) permettent de suivre chaque √©tape du traitement : analyse des arguments, validation des modes, et application des changements au canal.

**Tests for Mode**

**Commandes qui fonctionnent**
MODE #channel +i -tk +o user1 
Le canal est en mode "invite-only" (+i), sans sujet (-t), sans mdp (-k) et l'utilisateur user1 est op√©rateur (+o).

`MODE #channel +ilkto 10 key user`
canal est en mode "invite-only" (+i), avec un sujet restreint (+t), un mot de passe de 10 caract√®res (+k key), et une limite d'utilisateurs (+l), avec user comme utilisateur invit√©.
`MODE #channel +k password `
Le canal est prot√©g√© par un mot de passe (+k password).
`MODE #channel +o user1 -o user1`
er1 est ajout√© comme op√©rateur (+o), puis enlev√© (-o).
`MODE #channel +o user1 +o user2 +o user3 -o user4 +i -t `
er1, user2, et user3 deviennent op√©rateurs (+o), user4 est enlev√© comme op√©rateur (-o), le canal devient "invite-only" (+i), et le sujet est supprim√© (-t).
`MODE #channel +o user1 +o user2 +o user3 -o user4 `
er1, user2, et user3 deviennent op√©rateurs (+o), et user4 est enlev√© comme op√©rateur (-o).

MODE #channel +itk +o user1 
Le canal est en mode "invite-only" (+i), avec un sujet restreint (+t), sans mot de passe (-k), et l'utilisateur user1 est op√©rateur (+o). cependant pour simplifier, dans notre irc, la commande prendra user1 comme mdp car il traite +k et pas -k (alors que dans le vrai irc, s'il n y a pas de key,+k devient -k). => ne fonctionne pas chez nous

MODE #channel +i user1 -tk +o => user1 est utilis√© pour correspondre √† +o

**Commandes en erreur (adapted numeric replies)**
/mode
MODE :Not enough parameter
MODE #channel +i +tk +o user1 
MODE #channel +o =>missing argument
MODE #channel -o=>missing argument
MODE #channel +k=>missing argument
MODE #channel +l=>missing argument
MODE #channel +m =>m : unknown mode
MODE #channel ++ => + : unknown mode
/mode https://github.com/faboussard/42-irc/issues/1 +i =>#1:You're not a channel operator (si pas op)
MODE #channel +imst =>bloqu√© car ne connait pas m

j'ai √©galement fait une petit modif dans broadcast channel car si on changeait le topic on ne voyait pas son changement car je limitais le broadcast message : seul les receveurs voyaient la modif. 
jai ajout√© une condition que sur privmsg pour que les messages ne soit pas dupliqu√©es, mais que les autres actions soient bien re√ßues par tous.


```
void Server::broadcastInChannel(const Client &sender, const Channel &channel,
                                const std::string &command,
                                const std::string &content) {
  std::string message = ":" + sender.getNickname() + " " + command + " " +
                        channel.getNameWithPrefix() + " :" + content + "\r\n";
  const clientPMap &allClients = channel.getChannelClients();
  clientPMap::const_iterator itEnd = allClients.end();
  for (clientPMap::const_iterator it = allClients.begin(); it != itEnd; ++it) {
    if (it->first == sender.getFd() && command == "PRIVMSG")
      continue;
    it->second->receiveMessage(message);
  }
}
```



DEBUG GDB


gdb ./bin/ircserv -tui
b function_name + tab
run 6667 pass 
say no to debuging info 
connect to NC
enter joining info ( pass, nick ...) 
enter commands : if i want to process it i type c 
n to continue 
enter + emptyline will process the previous command 
 





